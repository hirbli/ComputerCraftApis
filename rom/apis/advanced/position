-- Position of Computer Relative to Coordinate System

-- Purpose:
--   Tracks the current position and orientation of the computer (or turtle).
--   The position and orientation is expressed in the form of a
--   linear transformation between the computer relative coordinates and
--   reference coordinates:
--      vReference = tPosition:apply(vRelative)
--   where tPosition is the transformation and vRelative and vReference
--   are vectors in the relative and reference coordinate system.
--   The relative coordinates are:
--     (0, 0, 0) position of computer
--     (1, 0, 0) one block in forward direction of computer
--     (0, 1, 0) one block above computer
--     (0, 0, 1) one block to the right of the computer
--   The reference coordinate system is initialized to be the same
--   as the relative coordinate system, but stays in place while
--   the turtle moves.
--   If a better reference coordinate system becomes available (e.g. via
--   galileo), the reference can be exchanged.

-- Todo:
--   coordinate system abstraction with conversion from one to other
--   abstraction of direction

local persist = loader.requireApi("persistency")
local tx = loader.requireApi("transformation")

-- Position Logic ---------------------------------------------------------

--local myID = os.getComputerID()
local initialLocation = {pos=tx.identity, moving=false}
local location = persist.new("position", initialLocation)
location.value.pos = tx.newFromTable(location.value.pos)
if location.value.moving then
  print("Position was changing during shutdown, resetting.")
  location.value = initialLocation
  -- reset other ???
end
location:store()

-- Movement -----------------------------------------------------------

local moveTx = nil

function startMoving(transformation)
  location.value.moving = true
  location:store()
  moveTx = transformation
end

function stopMoving(success)
  location.value.moving = false
  if success then
    location.value.pos = location.value.pos:concat(moveTx)
    moveTx = nil
  end
  location:store()
end

__lunit = {}

local function check(x, y, z, t)
  local pos=location.value.pos
  --pos.offset
end

function __lunit.path()
  location.value = initialLocation
  local fw = tx.move(vector.new(1, 0, 0))
  startMoving(fw)
  stopMoving(false)
  startMoving(fw)
  stopMoving(true)
  lunit.areEqual(fw, location.value.pos)
  startMoving(tx.turn(1))
  stopMoving(true)
  startMoving(fw)
  stopMoving(true)
  lunit.areEqual(vector.new(1, 0, -1), location.value.pos:apply(vector.new(0, 0, 0)))
  lunit.areEqual(vector.new(1, 0, -2), location.value.pos:apply(vector.new(1, 0, 0)))
end

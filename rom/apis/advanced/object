-- Class Functionality

-- Purpose:
--   provide a root class "object" that can be derived from
--   Classes have the functions inherited from the object class:
--     instance = class:new(...)
--     subClass = class:createSubclass(name)
--     name = class:getClassName()
--     superClass = class:getSuper()
--   Instances have the functions inherited from object
--     object:getClass()

--   To make your own class:
--     local class, instance = object.createSubclass("myClass")
--     function class:myClassMethod() end
--     function instance:myInstanceMethod() end
--     function instance:init(...) initialize class end

-- Todo:
--   classes using __index will hide some keys for their local storage: create indexer wrappers that redirect via a per instance metatable.


-- for lua 5.1
local oldPairs = pairs
local function newPairs(t)
  local mt = getmetatable(t)
  local p = (mt and mt.__pairs) or oldPairs
  return p(t)
end
rawset(_G, 'pairs', newPairs)


local function createVTable(class)
  local vt = {}
  vt.__index = vt
  function vt.getClass() return class end
  class._vtable = vt
  return vt
end

local function createInstanceFromClass(class)
  local inst = {}
  return setmetatable(inst, class._vtable)
end

local metaclass = {}
local metaclassvt = createVTable(metaclass)
function metaclassvt:getSuper()
  return self.super
end
function metaclassvt:getClassName()
  return self.className
end
function metaclassvt:new(...)
  o = createInstanceFromClass(self)
  local init = self._vtable.init
  if init then init(o, ...) end
  return o
end

local object = createInstanceFromClass(metaclass)
object.className = "object"
local objectvt = createVTable(object)
function object:createSubclass(name)
  local class = createInstanceFromClass(metaclass)
  local vt = createVTable(class)
  class.className = name
  class.super = self
  vt.super = self._vtable.__index
  table.copyNoOverwrite(self, class)
  table.copyNoOverwrite(self._vtable, vt)
  return class, vt
end

local test = {}
object.__lunit = test

function test.object()
  lunit.areEqual("object", object:getClassName())
  lunit.areEqual(nil, object:getSuper())
  lunit.areSame(metaclass, object:getClass())
end
function test.instance()
  local o = object:new()
  lunit.areSame(object, o:getClass())
  local o2 = object:new()
  lunit.areSame(true, o~=o2)
end
function test.subclass()
  local x, vt = object:createSubclass("x")
  function vt:init(a) self.val = a end
  lunit.areEqual("x", x:getClassName())
  lunit.areSame(object, x:getSuper())
  local o = x:new(4)
  lunit.areSame(x, o:getClass())
  lunit.areEqual(4, o.val)
end
function test.subSubClass()
  local x, vt = object:createSubclass("x")
  function vt:init(a) self.x = a end
  function vt:test() return 1 end
  local y, vt = x:createSubclass("y")
  function vt:init(a) self.y = a; self.super.init(self, a) end
  function vt:test() return 2 end
  local o = y:new(2)
  lunit.areEqual(2, o.x)
  lunit.areEqual(2, o.y)
  lunit.areEqual(2, o:test())
end

loader.installAsApi(object)
